\nuse std::mem;\n\nconst NB_FILTERS: usize = 2;\nconst NB_SUBBANDS: usize = 4;\nconst FILTER_TAPS: usize = 16;\n\nstatic APTX_QMF_INNER_COEFFS: [[i32; FILTER_TAPS]; NB_FILTERS] = [\n    [\n        1033, -584, -13592, 61697, -171156, 381799, -828088, 3962579,\n        985888, -226954, 39048, 11990, -14203, 4966, 973, -1268,\n    ],\n    [\n        -1268, 973, 4966, -14203, 11990, 39048, -226954, 985888,\n        3962579, -828088, 381799, -171156, 61697, -13592, -584, 1033,\n    ],\n];\n\nstatic APTX_QMF_OUTER_COEFFS: [[i32; FILTER_TAPS]; NB_FILTERS] = [\n    [\n        730, -413, -9611, 43626, -121026, 269973, -585547, 2801966,\n        697128, -160481, 27611, 8478, -10043, 3511, 688, -897,\n    ],\n    [\n        -897, 688, 3511, -10043, 8478, 27611, -160481, 697128,\n        2801966, -585547, 269973, -121026, 43626, -9611, -413, 730,\n    ],\n];\n\n#[derive(Default)]\nstruct AptxFilterSignal {\n    buffer: [i32; 2 * FILTER_TAPS],\n    pos: usize,\n}\n\n#[derive(Default)]\nstruct AptxPrediction {\n    prev_sign: [i32; 2],\n    s_weight: [i32; 2],\n    d_weight: [i32; 24],\n    pos: i32,\n    reconstructed_differences: [i32; 48],\n    previous_reconstructed_sample: i32,\n    predicted_difference: i32,\n    predicted_sample: i32,\n}\n\n#[derive(Default)]\nstruct AptxInvertQuantize {\n    quantization_factor: i32,\n    factor_select: i32,\n    reconstructed_difference: i32,\n}\n\n#[derive(Default)]\nstruct AptxQuantize {\n    quantized_sample: i32,\n    quantized_sample_parity_change: i32,\n    error: i32,\n}\n\n#[derive(Default)]\nstruct AptxQmfAnalysis {\n    outer_filter_signal: [AptxFilterSignal; NB_FILTERS],\n    inner_filter_signal: [[AptxFilterSignal; NB_FILTERS]; NB_FILTERS],\n}\n\n#[derive(Default)]\nstruct AptxChannel {\n    codeword_history: i32,\n    dither_parity: i32,\n    dither: [i32; NB_SUBBANDS],\n    qmf: AptxQmfAnalysis,\n    quantize: [AptxQuantize; NB_SUBBANDS],\n    invert_quantize: [AptxInvertQuantize; NB_SUBBANDS],\n    prediction: [AptxPrediction; NB_SUBBANDS],\n}\n\nfn clip_intp2(a: i32, p: u32) -> i32 {\n    if ((a.wrapping_add(1 << p)) as u32) & !((2 << p) - 1) != 0 {\n        return (a >> 31) ^ ((1 << p) - 1);\n    }\n    a\n}\n\nfn rshift64(value: i64, shift: u32) -> i64 {\n    let rounding = 1 << (shift - 1);\n    let mask = (1 << (shift + 1)) - 1;\n    ((value.wrapping_add(rounding)) >> shift) - ((value & mask == rounding) as i64)\n}\n\nfn rshift64_clip24(value: i64, shift: u32) -> i32 {\n    clip_intp2(rshift64(value, shift) as i32, 23)\n}\n\nfn aptx_qmf_convolution(signal: &AptxFilterSignal, coeffs: &[i32; FILTER_TAPS], shift: u32) -> i32 {\n    let sig = &signal.buffer[signal.pos];\n    let mut e: i64 = 0;\n\n    for i in 0..FILTER_TAPS {\n        e = e.wrapping_add((sig[i] as i64) * (coeffs[i] as i64));\n    }\n\n    rshift64_clip24(e, shift)\n}\n\nfn aptx_qmf_filter_signal_push(signal: &mut AptxFilterSignal, sample: i32) {\n    signal.buffer[signal.pos] = sample;\n    signal.buffer[signal.pos + FILTER_TAPS] = sample;\n    signal.pos = (signal.pos + 1) % FILTER_TAPS;\n}\n\nfn aptx_qmf_polyphase_synthesis(signal: &mut [AptxFilterSignal; NB_FILTERS],\n                                coeffs: &[[i32; FILTER_TAPS]; NB_FILTERS],\n                                shift: u32,\n                                low_subband_input: i32,\n                                high_subband_input: i32,\n                                samples: &mut [i32; NB_FILTERS]) {\n    let subbands: [i32; NB_FILTERS] = [\n        low_subband_input.wrapping_add(high_subband_input),\n        low_subband_input.wrapping_sub(high_subband_input),\n    ];\n\n    for i in 0..NB_FILTERS {\n        aptx_qmf_filter_signal_push(&mut signal[i], subbands[1 - i]);\n        samples[i] = aptx_qmf_convolution(&signal[i], coeffs[i], shift);\n    }\n}\n\nfn aptx_qmf_tree_synthesis(qmf: &mut AptxQmfAnalysis, subband_samples: &[i32; NB_SUBBANDS], samples: &mut [i32; 4]) {\n    let mut intermediate_samples: [i32; 4] = Default::default();\n\n    for i in 0..2 {\n        aptx_qmf_polyphase_synthesis(&mut qmf.inner_filter_signal[i], &APTX_QMF_INNER_COEFFS, 22,\n                                     subband_samples[2 * i + 0], subband_samples[2 * i + 1],\n                                     &mut intermediate_samples[2 * i..]);\n    }\n\n    for i in 0..2 {\n        aptx_qmf_polyphase_synthesis(&mut qmf.outer_filter_signal, &APTX_QMF_OUTER_COEFFS, 21,\n                                     intermediate_samples[i], intermediate_samples[2 + i],\n                                     &mut samples[2 * i..]);\n    }\n}\n\nfn aptx_decode_channel(channel: &mut AptxChannel, samples: &mut [i32; 4]) {\n    let mut subband_samples: [i32; NB_SUBBANDS] = Default::default();\n\n    for subband in 0..NB_SUBBANDS {\n        subband_samples[subband] = channel.prediction[subband].previous_reconstructed_sample;\n    }\n    aptx_qmf_tree_synthesis(&mut channel.qmf, &subband_samples, samples);\n}\n